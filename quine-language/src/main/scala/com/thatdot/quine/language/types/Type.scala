package com.thatdot.quine.language.types

import cats.Semigroup
import cats.data.NonEmptyList

/** Constraints that restrict what types a TypeVariable can be unified with.
  *
  * Constraints are used during type inference to express that a type variable
  * must eventually resolve to a type with certain properties. For example,
  * the `-` operator requires both operands to be Numeric.
  */
sealed trait Constraint

object Constraint {

  /** No constraint - the type variable can unify with any type. */
  case object None extends Constraint

  /** Numeric constraint - the type must be Integer or Real.
    * Used for arithmetic operators: -, *, /, %, ^
    */
  case object Numeric extends Constraint

  /** Semigroup constraint - the type must support concatenation/addition.
    * Satisfied by Integer, Real, and String.
    * Used for the + operator which can mean numeric addition or string concatenation.
    */
  case object Semigroup extends Constraint
}

/** The type system for Cypher expressions.
  *
  * This is a Hindley-Milner style type system with:
  * - Primitive types (Integer, Real, Boolean, String, NodeType)
  * - Parameterized types via TypeConstructor (List[T], Map[K,V])
  * - Type variables for inference
  * - Constraints on type variables
  * - Special types (Any, Null, Error) for compatibility and error handling
  *
  * == Type Inference ==
  *
  * During type checking, expressions initially get TypeVariables as their types.
  * Through unification, these variables get bound to concrete types. The type
  * environment (typeEnv in TypeCheckingState) maps variable symbols to their
  * resolved types.
  *
  * == Type Compatibility ==
  *
  * - Any unifies with all types (top type)
  * - Null unifies with all types (for null-safety)
  * - Error indicates a type error occurred (propagates through expressions)
  * - Effectful wraps types that may have side effects
  */
sealed trait Type

object Type {
  //FIXME Obviously this is bad... could potentially do a pure unify here?
  // Note: This semigroup just picks the right-hand side, which is incorrect
  // for a proper type semigroup. Should implement unification instead.
  implicit val tsg: Semigroup[Type] = (t1: Type, t2: Type) => t2

  /** Top type - unifies with any other type.
    * Used when the type is truly unknown or doesn't matter.
    */
  case object Any extends Type

  /** Null type - represents the null value.
    * Unifies with any type to support null-safe operations.
    */
  case object Null extends Type

  /** Error type - indicates a type error occurred.
    * Returned when type checking fails for an expression.
    */
  case object Error extends Type

  /** Wrapper for types that may have side effects.
    * Used to track effectful computations in the type system.
    *
    * @param valueType The underlying value type
    */
  case class Effectful(valueType: Type) extends Type

  /** Parameterized type constructor.
    *
    * Represents generic types like List[T] or Map[K,V].
    *
    * @param id   Unique identifier for the type constructor (e.g., 'List, 'Map)
    * @param args Type arguments (NonEmptyList ensures at least one argument)
    *
    * @example List[Integer] = TypeConstructor('List, NonEmptyList.of(PrimitiveType.Integer))
    */
  case class TypeConstructor(id: Symbol, args: NonEmptyList[Type]) extends Type

  /** Type variable for type inference.
    *
    * Represents an unknown type that will be determined through unification.
    * May carry a constraint restricting what types it can be bound to.
    *
    * @param id         Unique identifier for this variable (generated by `freshen`)
    * @param constraint Restriction on what types this variable can unify with
    *
    * @example TypeVariable('x_42, Constraint.Numeric) - must be Integer or Real
    */
  case class TypeVariable(id: Symbol, constraint: Constraint) extends Type

  /** Factory for Any type */
  def any: Type = Any

  /** Factory for Error type */
  def error: Type = Error

  /** Factory for Null type */
  def nullTy: Type = Null

  /** Built-in primitive types for Cypher.
    */
  sealed trait PrimitiveType extends Type

  object PrimitiveType {

    /** 64-bit signed integer */
    case object Integer extends PrimitiveType

    /** 64-bit floating point number */
    case object Real extends PrimitiveType

    /** Boolean true/false */
    case object Boolean extends PrimitiveType

    /** Unicode string */
    case object String extends PrimitiveType

    /** Graph node reference */
    case object NodeType extends PrimitiveType
  }
}
